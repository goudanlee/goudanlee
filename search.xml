<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[DAND“整理 OpenStreetMap 数据”学习总结]]></title>
      <url>/2017/05/20/dand-osm/</url>
      <content type="html"><![CDATA[<p>讲真，一开始让我写一篇这样的文章我是拒绝的，因为我以前总是觉得，学习是自己的事情，学到多少，学了什么，自己清楚就好。不过，在优达学城近两个月的学习之后，我逐步改变了观点，正如优达优等生互助班所倡导的“探索、自律、分享”的学习理念，实际上学习过程中的积累和分享的过程，也是提升学习兴趣的一个非常重要的点。所以，今天也想在这里汇总一下关于DAND课程里P3项目“整理 OpenStreetMap 数据”这阶段的学习总结，同时也记录一下自己的学习心路历程，这里特别感谢一下优等生互助班导师——鱼头同学的各种鼓励和支持@Clark Yu，非常负责任的一位导师，为了我们的学习进度也是操碎了心 /捂脸<br>应该说整个P3过程涉及的知识点还是比较多的，P3项目的要求是探索整理OpenStreetMap上的数据，并完成清洗、探索、分析的过程，这部分内容，应该是数据分析过程中一个相当耗时的部分，所以整个P3项目的预计完成时间还是比较长的。P3课程主要核心内容为：</p>
<h4 id="数据分析提取"><a href="#数据分析提取" class="headerlink" title="数据分析提取"></a>数据分析提取</h4><h4 id="数据质量审查"><a href="#数据质量审查" class="headerlink" title="数据质量审查"></a>数据质量审查</h4><h4 id="清洗整理osm数据并使用SQL-MongoDB存储数据进行数据探索"><a href="#清洗整理osm数据并使用SQL-MongoDB存储数据进行数据探索" class="headerlink" title="清洗整理osm数据并使用SQL/MongoDB存储数据进行数据探索"></a>清洗整理osm数据并使用SQL/MongoDB存储数据进行数据探索</h4><h5 id="数据分析提取-1"><a href="#数据分析提取-1" class="headerlink" title="数据分析提取"></a>数据分析提取</h5><p>课程主要包含了使用Python从各个数据源分析提取数据的过程，处理的数据来源有CSV、Excel、JSON、XML以及HTML，这几类数据源都是比较常见的数据源，基本覆盖了我们常见的获取数据的途径，其中CSV、XML是格式比较标准且出现度非常高的两种文件格式，而JSON简洁和清晰的层次结构使得 JSON 成为一种理想的数据交换格式，它的键值对模式，非常类似Python中的字典，使用Python处理起来非常方便。</p>
<p>而对于HTML的数据提取，其实就是对网页上的内容进行的爬取和格式处理，课程里使用了Python中非常友好的BeatifulSoup库进行爬虫开发，非常容易的实现了对于网页内容的爬取。不过，鉴于课程的设计，关于爬虫的教学实际上并不是很深入，只是比较浅显的介绍了对于静态网页内容的爬取，在现在动态加载页面大行其道的今天，还是显得有点力不从心了，后续的实际过程中若数据来源比较多来自于HTML，那还是得深入对爬虫做一番了解。</p>
<p>Python读取各数据格式的API文档地址汇总：</p>
<h5 id="CSV"><a href="#CSV" class="headerlink" title="CSV:"></a>CSV:</h5><p>所用Python库：import csv</p>
<p>API文档： CSV File Reading and Writing - Python 2.7.13 documentation</p>
<h5 id="Excel"><a href="#Excel" class="headerlink" title="Excel:"></a>Excel:</h5><p>所用Python库：import xlrd</p>
<p>API文档： API Reference - xlrd 1.0.0 documentation</p>
<h5 id="JSON"><a href="#JSON" class="headerlink" title="JSON:"></a>JSON:</h5><p>所用Python库：import json</p>
<p>API文档： 18.2. json — JSON encoder and decoder</p>
<h5 id="XML"><a href="#XML" class="headerlink" title="XML:"></a>XML:</h5><p>所用Python库：import xml</p>
<p>API文档： 19.8. xml.dom — The Document Object Model API</p>
<h4 id="数据质量审查："><a href="#数据质量审查：" class="headerlink" title="数据质量审查："></a>数据质量审查：</h4><p>作为一个合格的DataAnalyst，自然要对所需进行探索分析的数据的质量有清晰的认识。对于数据质量的审查与清理是一个不断迭代的过程，数据质量在数据分析中的重要性毋庸置疑，数据的质量直接影响数据的产出和数据价值高低，而数据质量的基本要素则包含以下3个要素：</p>
<h5 id="1、准确性"><a href="#1、准确性" class="headerlink" title="1、准确性"></a>1、准确性</h5><p>数据中记录的信息和数据是否准确，是否存在异常或者错误的信息。</p>
<p>导致一致性问题的原因可能是数据记录的规则不一，但不一定存在错误；而准确性关注的是数据记录中存在的错误，比如字符型数据的乱码现象也应该归到准确性的考核范畴，另外就是异常的数值，异常大或者异常小的数值，不符合有效性要求的数值，如访问量Visits一定是整数、年龄一般在1-100之间、转化率一定是介于0到1的值等。对数据准确性的审核有时会遇到困难，因为对于没有明显异常的错误值我们很难发现。</p>
<h5 id="2、完整性"><a href="#2、完整性" class="headerlink" title="2、完整性"></a>2、完整性</h5><p>数据的记录和信息是否完整，是否存在缺失的情况。</p>
<p>数据的缺失主要有记录的缺失和记录中某个字段信息的缺失，两者都会造成统计结果的不准确，所以完整性是数据质量最基础的保障，而对完整性的评估相对比较容易。</p>
<h5 id="3、一致性"><a href="#3、一致性" class="headerlink" title="3、一致性"></a>3、一致性</h5><p>数据的记录是否符合规范，是否与前后及其他数据集合保持统一。</p>
<p>数据的一致性主要包括数据记录的规范和数据逻辑的一致性。数据记录的规范主要是数据编码和格式的问题，比如网站的用户ID是15位的数字、商品ID是10位数字，商品包括20个类目、IP地址一定是用”.”分隔的4个0-255的数字组成，及一些定义的数据约束，比如完整性的非空约束、唯一值约束等；数据逻辑性主要是指标统计和计算的一致性，比如PV&gt;=UV，新用户比例在0-1之间等。数据的一致性审核是数据质量审核中比较重要也是比较复杂的一块。</p>
<h4 id="使用SQL-MongoDB存储数据并分析"><a href="#使用SQL-MongoDB存储数据并分析" class="headerlink" title="使用SQL/MongoDB存储数据并分析"></a>使用SQL/MongoDB存储数据并分析</h4><p>课程里关于使用SQL还是MongoDB是需要学员根据自己的情况自行选择的，由于我工作中接触SQL比较多，所以这里我选择了MongoDB。</p>
<p>MongoDB 是一个基于分布式文件存储的数据库，他是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p>
<p>MongoDB 3.4 中文文档<br>MongoDB - MongoDB Manual 3.4</p>
<h5 id="MongoDB常用的操作："><a href="#MongoDB常用的操作：" class="headerlink" title="MongoDB常用的操作："></a>MongoDB常用的操作：</h5><h5 id="MongoDB导入语句"><a href="#MongoDB导入语句" class="headerlink" title="MongoDB导入语句"></a>MongoDB导入语句</h5><p>使用Mongoimport命令，适用于已有文件导入<br>mongoimport -d dbname -c collectionname –file input-file.json<br>语句导入<br>db.cities.insert({“name” : “Chicago”})</p>
<h6 id="1-查询"><a href="#1-查询" class="headerlink" title="1.查询"></a>1.查询</h6><h6 id="1-1-条件查询"><a href="#1-1-条件查询" class="headerlink" title="1.1 条件查询"></a>1.1 条件查询</h6><p>db.cities.find(“name”: “Guangzhou”, “class”: “mid-size car”)</p>
<h6 id="1-2-投影查询"><a href="#1-2-投影查询" class="headerlink" title="1.2 投影查询"></a>1.2 投影查询</h6><p>query = {“name”: “Guangzhou”, “class”: “mid-size car”}<br>projection = {“_id” : 0,”name” : 1}<br>db.cities.find(query, projection)</p>
<h6 id="1-3-范围查询"><a href="#1-3-范围查询" class="headerlink" title="1.3 范围查询"></a>1.3 范围查询</h6><p>运算符：<br>(&gt;) 大于 - $gt<br>(&lt;) 小于 - $lt<br>(&gt;=) 大于等于 - $gte<br>(&lt;= ) 小于等于 - $lte<br>$gt ——– greater than $gte ——— gt equal $lt ——– less than $lte ——— lt equal $ne ———– not equalquery = {“foundingDate”: {“$gte” : datetime(2000,1,1)}}<br>db.cities.find(query)</p>
<h6 id="1-4-Exists查询"><a href="#1-4-Exists查询" class="headerlink" title="1.4 Exists查询"></a>1.4 Exists查询</h6><p>query = {“name”: {“$exists” : 1}}</p>
<h6 id="1-5-正则表达式查询"><a href="#1-5-正则表达式查询" class="headerlink" title="1.5 正则表达式查询"></a>1.5 正则表达式查询</h6><p>query = {“name”: {“$regex” : “[Ff]riendship|[Pp]ride”}}</p>
<h6 id="1-6-in查询"><a href="#1-6-in查询" class="headerlink" title="1.6 in查询"></a>1.6 in查询</h6><p>query = {“manufacturer”:”Ford Motor Company”,”assembly”:{“$in”:[“Germany”,”United Kingdom”,”Japan”]}}</p>
<h6 id="1-7-all查询"><a href="#1-7-all查询" class="headerlink" title="1.7 all查询"></a>1.7 all查询</h6><p>query = {“manufacturer”:”Ford Motor Company”,”assembly”:{“$all”:[“Germany”,”United Kingdom”,”Japan”]}}</p>
<h6 id="1-8点表示法"><a href="#1-8点表示法" class="headerlink" title="1.8点表示法"></a>1.8点表示法</h6><p>query = {“dimensions.width”:{“$gt”:2.5}}</p>
<h5 id="2-更新"><a href="#2-更新" class="headerlink" title="2.更新"></a>2.更新</h5><h6 id="2-1-save-方法"><a href="#2-1-save-方法" class="headerlink" title="2.1 save()方法"></a>2.1 save()方法</h6><p>city = db.cities.find_one({“name” : “Munchen”},<br>“country” : “Germany”)<br>city[“isoCountryCode”] = “DEU”<br>db.cities.save(city)</p>
<h6 id="2-2-update-方法-set-amp-unset"><a href="#2-2-update-方法-set-amp-unset" class="headerlink" title="2.2 update()方法 set &amp; unset"></a>2.2 update()方法 set &amp; unset</h6><p>set:<br>city = db.cities.update({“name” : “Munchen”},<br>“country” : “Germany”,<br>{“$set” : {“isoCountryCode” : “DEU”}}<br>)</p>
<p>unset:<br>city = db.cities.update({“name” : “Munchen”},<br>“country” : “Germany”,<br>{“$set” : {“isoCountryCode” : “”}}<br>)</p>
<h6 id="2-3-update-多项更新"><a href="#2-3-update-多项更新" class="headerlink" title="2.3 update()多项更新"></a>2.3 update()多项更新</h6><p>city = db.cities.update({“name” : “Munchen”},<br>“country” : “Germany”,<br>{“$set” : {“isoCountryCode” : “”}}<br>，multi = True)</p>
<h5 id="3-删除"><a href="#3-删除" class="headerlink" title="3.删除"></a>3.删除</h5><p>类似find语法<br>db.cities.remove(“name”: “Guangzhou”, “class”: “mid-size car”)<br>db.cities.drop()删除collection所有内容</p>
<h5 id="4-聚合框架"><a href="#4-聚合框架" class="headerlink" title="4.聚合框架"></a>4.聚合框架</h5><h6 id="4-1聚合框架使用："><a href="#4-1聚合框架使用：" class="headerlink" title="4.1聚合框架使用："></a>4.1聚合框架使用：</h6><p>db.tweets.aggregate([<br>{“$group” : {“_id” : “$user.screen_name”,<br>“count” : {“$sum” : 1}}},<br>{“$sort” : {“count” : -1}}])</p>
<h6 id="4-2-match-amp-project运算符："><a href="#4-2-match-amp-project运算符：" class="headerlink" title="4.2 match&amp;project运算符："></a>4.2 match&amp;project运算符：</h6><p>db.tweets.aggregate([<br>{“$match” : {“user.friends_count” : {“$gt” : 0},<br>“user.followers_count”: {“$gt” : 0}}},<br>{“$project”: {“ratio” : {“$divide” : [“$user.followers_count”,<br>“$user.friends_count”]},<br>“screen_name” : “$user.screen_name”}},<br>{“$sort” : {“ratio” : -1}},<br>{“$limit” : 1}])</p>
<h6 id="4-3-unwind运算符："><a href="#4-3-unwind运算符：" class="headerlink" title="4.3 unwind运算符："></a>4.3 unwind运算符：</h6><p>db.tweets.aggregate([<br>{“$unwind” : “$entities.user_mentions”},<br>{“$group” : {“_id” : “$user.screen_name”,<br>“count” : {“$sum” : 1}}},<br>{“sort” : {“count” : -1}}])</p>
<h6 id="分组累加运算符："><a href="#分组累加运算符：" class="headerlink" title="分组累加运算符："></a>分组累加运算符：</h6><p>$sum</p>
<p>$first</p>
<p>$last</p>
<p>$max</p>
<p>$min</p>
<p>$avg</p>
<p>$push (Arrays)</p>
<p>$addToSet (Arrays)</p>
<h6 id="avg"><a href="#avg" class="headerlink" title="avg:"></a>avg:</h6><p>db.tweets.aggregate([</p>
<p>{“$unwind” : “$entities.hashtags”},</p>
<p>{“$group” : {“_id” : “$entities.hashtags.text”,</p>
<p>“retweet_avg” : {“$avg” : “$retweet_count”}}},</p>
<p>{“sort” : {“retweet_avg” : -1}}])</p>
<h6 id="addToSet"><a href="#addToSet" class="headerlink" title="addToSet:"></a>addToSet:</h6><p>db.tweets.aggregate([</p>
<p>{“$unwind” : “$entities.hashtags”},</p>
<p>{“$group” : {“_id” : “$entities.hashtags.text”,</p>
<p>“unique_hashtags” : {“$addToSet” : </p>
<p>“$entities.hashtags.text”}}},</p>
<p>{“sort” : {“retweet_avg” : -1}}])</p>
]]></content>
      
        <categories>
            
            <category> DAND </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DAND </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> MongoDB </tag>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello HEXO]]></title>
      <url>/2017/05/19/HelloHEXO/</url>
      <content type="html"><![CDATA[<p>本着不折腾不死的精神，费了6个小时，终于把HEXO + github pages的博客搭建起来了，虽然搭建教程一大堆，不过，有些问题还是得自己摸索去解决。不过其实最费时间的其实是注册域名的过程，这里吐槽一下西部数码域名商，域名管理功能实在是差劲，本来早就屯了4个域名，心想这次能用上了，结果各种域名过户失败，导致无法修改DNS解析，提交工单也只是说让重试。一气之下，直接重新在阿里云注册了.com域名，并顺利做好DNS解析（真的不是广告~逃）</p>
<p>别说，HEXO还是用着很爽，可以愉快的使用markdown了，这下可以把之前数据分析的相关.md直接发布过来了，哈哈哈！最关键的是没有那么多限制了，自己的后台，自己的域名，爱怎么折腾怎么折腾。github pages简直是解放VPS管理的神器，不用关心服务器，web服务了，安心写内容即可，赞赞赞！新博客第一篇，Mark一下，改天陆续把以前的文章迁移过来。</p>
<p><a href="https://hexo.io/zh-cn/docs/writing.html" target="_blank" rel="external">HEXO’s document</a></p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HEXO </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[shell实现web服务进程监控并自动重启]]></title>
      <url>/2017/02/09/shell-monitor/</url>
      <content type="html"><![CDATA[<h3 id="一、目的需求"><a href="#一、目的需求" class="headerlink" title="一、目的需求"></a>一、目的需求</h3><p>根据业务需要，目前负责维护的产品形式基本是属于分布式的，有多个web服务部署在不同项目现场，针对这些web服务的维护就成了比较麻烦的事情。为了保障系统服务，之前已经采用LNMP+zabbix的方案搭建了一套web服务监控系统，可以方便的查看各项目的web服务状态，方便及时发现问题并解决。<br>采用Grafana的前端监控界面（比zabbix自带的图表好看点 - -）：<br><img src="/2017/02/09/shell-monitor/1.png" alt="1.png" title=""> </p>
<p>不过虽然有zabbix贴心的监控和提醒（实际上由于网络不稳定或等等玄学因素，冗余警告非常多，多了就烦了。。。），但是解决具体问题还是需要远程到项目现场进行，特别是一些进程运行时间久了之后的异常，或者数据库连接异常断开等，简单重启一下web服务即可解决。但是，问题频繁了之后就很浪费时间了，于是打算通过shell来监控各项目地的web服务并实现异常自动重启，作为程序猿，当然要用代码来偷懒啦~（懒惰是三大生产力之一）</p>
<h3 id="二、分析过程"><a href="#二、分析过程" class="headerlink" title="二、分析过程"></a>二、分析过程</h3><p>思路如下：</p>
<p>1.定时执行monitor监控脚本，获取服务状态；</p>
<p>2.monitor功能：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>:web服务异常</div><div class="line"></div><div class="line">   restart web服务</div><div class="line"></div><div class="line"><span class="keyword">else</span>:皆大欢喜</div></pre></td></tr></table></figure></p>
<p>逻辑很简单清楚，貌似很容易，不过这里有一个问题，如何判定web服务异常？</p>
<p><strong>根据实际经验，异常常见原因共如下几种：</strong></p>
<p>1.web服务进程莫名挂掉；</p>
<p>2.web服务数据库连接失败，多次尝试后挂起；</p>
<p>3.项目地网络出现波动；（不用吐槽，教育网还有偏远地区是这样的，指不定哪天光纤被挖断或者交换机故障(╯▽╰)）</p>
<p><strong>对应解决方案：</strong></p>
<p>1.判断进程是否存在，不存在则重启web服务；</p>
<p>2.这个直接通过shell不好判断，借鉴了之前在zabbix做http监控时的方法，通过模拟登录的方式，登录一个测试页面，获取http_code，若200则正常，非200则属于异常。</p>
<p>3.这个可以通过判断本地服务，如果本地访问无问题则正常。</p>
<h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><p>monitor逻辑分析清楚了，可以开始进行了，其中模拟登录使用curl来获取http_code。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#! /bin/sh  </span></div><div class="line">  </div><div class="line">host_dir=<span class="string">"/opt/ybg/"</span>                                     <span class="comment"># 当前用户根目录  </span></div><div class="line">proc_name=<span class="string">"java"</span>                                        <span class="comment"># 进程名  </span></div><div class="line">file_name=<span class="string">"monitor.log"</span>                                <span class="comment"># 日志文件  </span></div><div class="line">pid=0  </div><div class="line">  </div><div class="line">proc_num()                                              <span class="comment"># 计算进程数  </span></div><div class="line">&#123;  </div><div class="line">    num=`ps -ef | grep <span class="variable">$proc_name</span> | grep -v grep | wc <span class="_">-l</span>`  </div><div class="line">    <span class="built_in">return</span> <span class="variable">$num</span>  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">proc_id()                                               <span class="comment"># 进程号  </span></div><div class="line">&#123;  </div><div class="line">    pid=`ps -ef | grep <span class="variable">$proc_name</span> | grep -v grep | awk <span class="string">'&#123;print $2&#125;'</span>`  </div><div class="line">&#125;  </div><div class="line"><span class="comment"># 通过curl模拟登录获取http_code,模拟登录参数仅供参考</span></div><div class="line"><span class="comment"># 如果只需要判断某页面的状态可使用curl -I -s -w "%&#123;http_code&#125;" -o /dev/null http://www.baidu.com/ 直接获取即可</span></div><div class="line">http_code=`curl -I <span class="_">-s</span> -w <span class="string">"%&#123;http_code&#125;"</span> -o <span class="_">-d</span> <span class="string">"userKey=admin&amp;pass=c9127e832b41a"</span> /dev/null  http://portal.ly-sky.com/login.do?login= | head -n 1 | cut <span class="_">-d</span>$<span class="string">' '</span> <span class="_">-f</span>2`  </div><div class="line"></div><div class="line">proc_num  </div><div class="line">number=$?  </div><div class="line"><span class="keyword">if</span> [[ <span class="variable">$number</span> <span class="_">-eq</span> 0 ]]||[[ <span class="variable">$http_code</span> <span class="_">-ne</span> 200 ]]          <span class="comment"># 判断进程是否存在  </span></div><div class="line"><span class="keyword">then</span>   </div><div class="line">    <span class="built_in">cd</span> /opt/ybg/URP/bin/</div><div class="line">    nohup ./run.sh&gt;../logs/urp.log 2&gt;&amp;1 &amp;    <span class="comment"># 重启进程的命令，请相应修改  </span></div><div class="line">    sleep 3                                  <span class="comment">#延迟3秒是为了确保进程已正常启动并方便获取pid，否则有可能获取不到pid</span></div><div class="line">trueproc_id                                         <span class="comment"># 获取新进程号  </span></div><div class="line">    <span class="built_in">echo</span> <span class="variable">$pid</span>, `date` &gt;&gt; <span class="variable">$host_dir</span><span class="variable">$file_name</span>      <span class="comment"># 将新进程号和重启时间记录  </span></div><div class="line"><span class="keyword">fi</span> </div></pre></td></tr></table></figure></p>
<p>执行成功的日志记录：</p>
<p>记录了PID和启动时间，前面几条就是因为未加入sleep获取Pid失败，显示为空了</p>
<img src="/2017/02/09/shell-monitor/2.png" alt="2.png" title="">   
<h3 id="四、安装部署"><a href="#四、安装部署" class="headerlink" title="四、安装部署"></a>四、安装部署</h3><p>部署到服务器后只需要在crontab添加任务，定时执行就行了：</p>
<p>[root@localhost ybg]# crontab -e  </p>
<p>添加web服务监控，每5分钟一次，可根据实际要求修改监控频率.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*/5 * * * * /opt/monitor.sh</div></pre></td></tr></table></figure></p>
<p>添加完毕后，可以手动kill -9 pid来测试监控是否正常运行。提示：测试时注意生产环境哦，如果服务宕了被老板请去喝茶就不好啦~✧(≖ ◡ ≖✿)</p>
]]></content>
      
        <categories>
            
            <category> Shell </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Shell </tag>
            
            <tag> Zabbix </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Oracle索引原理]]></title>
      <url>/2016/10/14/oracle-index/index/</url>
      <content type="html"><![CDATA[<h3 id="B-TREE索引"><a href="#B-TREE索引" class="headerlink" title="B-TREE索引"></a>B-TREE索引</h3><p>一个B树索引只有一个根节点，它实际就是位于树的最顶端的分支节点。<br>可以用下图一来描述B树索引的结构。其中，B表示分支节点，而L表示叶子节点。<br><img src="/2016/10/14/oracle-index/index/1.jpg" alt="B-Tree Index" title="B-Tree Index">  </p>
<p>对于分支节点块（包括根节点块）来说，其所包含的索引条目都是按照顺序排列的（缺省是升序排列，也可以在创建索引时指定为降序排列）。每个索引条目（也可以叫做每条记录）都具有两个字段。第一个字段表示当前该分支节点块下面所链接的索引块中所包含的最小键值；第二个字段为四个字节，表示所链接的索引块的地址，该地址指向下面一个索引块。在一个分支节点块中所能容纳的记录行数由数据块大小以及索引键值的长度决定。比如从上图一可以看到，对于根节点块来说，包含三条记录，分别为（0 B1）、（500 B2）、（1000 B3），它们指向三个分支节点块。其中的0、500和1000分别表示这三个分支节点块所链接的键值的最小值。而B1、B2和B3则表示所指向的三个分支节点块的地址。</p>
<p>对于叶子节点块来说，其所包含的索引条目与分支节点一样，都是按照顺序排列的（缺省是升序排列，也可以在创建索引时指定为降序排列）。每个索引条目（也可以叫做每条记录）也具有两个字段。第一个字段表示索引的键值，对于单列索引来说是一个值；而对于多列索引来说则是多个值组合在一起的。第二个字段表示键值所对应的记录行的ROWID，该ROWID是记录行在表里的物理地址。如果索引是创建在非分区表上或者索引是分区表上的本地索引的话，则该ROWID占用6个字节；如果索引是创建在分区表上的全局索引的话，则该ROWID占用10个字节。</p>
<h3 id="bitmap索引"><a href="#bitmap索引" class="headerlink" title="bitmap索引"></a>bitmap索引</h3><p>位图（bitmap）索引是另外一种索引类型，它的组织形式与B树索引相同，也是一棵平衡树。与B树索引的区别在于叶子节点里存放索引条目的方式不同。从前面我们知道，B树索引的叶子节点里，对于表里的每个数据行，如果被索引列的值不为空的，则会为该记录行在叶子节点里维护一个对应的索引条目。而位图索引则不是这样，其叶子节点里存放的索引条目如下图所示。</p>
<p>假设某个表T里所有的记录在列C1上只具有三个值：01、02和03。在表T的C1列上创建位图索引以后，则叶子节点的内容如图9-14所示。可以看到，位图索引只有三个索引条目，也就是每个C1列的值对应一个索引条目。位图索引条目上还包含表里第一条记录所对应的ROWID以及最后一条记录所对应的ROWID。索引条目的最后一部分则是由多个bit位所组成的bitmap，每个bit位就对应一条记录。<br><img src="/2016/10/14/oracle-index/index/2.jpg" alt="B-Tree Index" title="B-Tree Index"> </p>
<p>当发出where c1=’01’这样的SQL语句时，oracle会去搜索01所在的索引条目，然后扫描该索引条目中的bitmap里所有的bit位。第一个bit位为1，则说明第一条记录上的C1值为01，于是返回第一条记录所在的ROWID（根据该索引条目里记录的start ROWID加上行号得到该记录所在的ROWID）。第二个bit位为0，则说明第二条记录上的C1值不为01，依此类推。另外，如果索引列为空，也会在位图索引里记录，也就是将对应的bit位设置为0即可。</p>
<p>如果索引列上不同值的个数比较少的时候，比如对于性别列（男或女）等，则使用位图索引会比较好，因为它对空间的占用非常少（因为都是用bit位来表示表里的数据行），从而在扫描索引的时候，扫描的索引块的个数也比较少。可以试想一下，如果在列的不同值非常多的列上，比如主键列上，创建位图索引，则产生的索引条目就等于表里记录的条数，同时每个索引条目里的bitmap里，只有一个1，其它都是0。这样还不如B树索引的效率高。<br>如果被索引的列经常被更新的话，则不适合使用位图索引。因为当更新位图所在的列时，由于要在不同的索引条目之间修改bit位，比如将第一条记录从01变为02，则必须将01所在的索引条目的第一个bit位改为0，再将02所在的索引条目的第一个bit位改为1。因此，在更新索引条目的过程中，会锁定位图索引里多个索引条目。也就是同时只能有一个用户能够更新表T，从而降低了并发性。位图索引比较适合用在数据仓库系统里，不适合用在OLTP系统里。</p>
<h3 id="HASH索引"><a href="#HASH索引" class="headerlink" title="HASH索引"></a>HASH索引</h3><p>使用HASH索引必须要使用HASH集群。建立一个集群或HASH集群的同时，也就定义了一个集群键。这个键告诉Oracle如何在集群上存储表。在存储数据时，所有与这个集群键相关的行都被存储在一个数据库块上。如果数据都存储在同一个数据库块上，并且将HASH索引作为WHERE子句中的确切匹配，Oracle就可以通过执行一个HASH函数和I/O来访问数据– 而通过使用一个二元高度为4的B树索引来访问数据，则需要在检索数据时使用4个I/O。如图2-5所示，其中的查询是一个等价查询，用于匹配HASH列和确切的值。Oracle可以快速使用该值，基于HASH函数确定行的物理存储位置。</p>
<p>HASH索引可能是访问数据库中数据的最快方法，但它也有自身的缺点。集群键上不同值的数目必须在创建HASH集群之前就要知道。需要在创建HASH集群的时候指定这个值。低估了集群键的不同值的数字可能会造成集群的冲突(两个集群的键值拥有相同的HASH值)。这种冲突是非常消耗资源的。冲突会造成用来存储额外行的缓冲溢出，然后造成额外的I/O。如果不同HASH值的数目已经被低估，您就必须在重建这个集群之后改变这个值。ALTER CLUSTER命令不能改变HASH键的数目。</p>
<p>HASH集群还可能浪费空间。如果无法确定需要多少空间来维护某个集群键上的所有行，就可能造成空间的浪费。如果不能为集群的未来增长分配好附加的空间，HASH集群可能就不是最好的选择。</p>
<p>如果应用程序经常在集群表上进行全表扫描，HASH集群可能也不是最好的选择。由于需要为未来的增长分配好集群的剩余空间量，全表扫描可能非常消耗资源。<br><img src="/2016/10/14/oracle-index/index/3.jpg" alt="B-Tree Index" title="B-Tree Index"> </p>
<p>在实现HASH集群之前一定要小心。您需要全面地观察应用程序，保证在实现这个选项之前已经了解关于表和数据的大量信息。通常，HASH对于一些包含有序值的静态数据非常有效。</p>
<p>技巧：</p>
<p>HASH索引在有限制条件(需要指定一个确定的值而不是一个值范围)的情况下非常有用。</p>
<h3 id="聚族索引"><a href="#聚族索引" class="headerlink" title="聚族索引"></a>聚族索引</h3><p>在这里还是用字典来进行类比，一般来说汉语字典中有几种索引，如拼音、偏旁、笔画等。字典本身的组织也是排序的，我记得一般是按照拼音排序的。这里的拼音就是聚族索引。也就是说聚族索引的组织顺序和数据本身的组织顺序是一致的 ，这也解释了数据库中只能定义一个聚族索引的原因，因为数据本身只能按一种方式进行排序。  </p>
<p>那聚族索引有什么特别的好处呢，这个好处就是在数据库中执行查找一批数据的语句会比较快，因为数据已经按照聚族索引排好序了，很少的io操作就可以将数据从库中取出。好比你在字典中查找发音从从a到c的汉字，只需要查到a的开始页和c的结束页，中间的所有页都符合查询要求，不用再一页一页地查找。<br><img src="/2016/10/14/oracle-index/index/4.jpg" alt="B-Tree Index" title="B-Tree Index"> </p>
<h3 id="非聚族索引"><a href="#非聚族索引" class="headerlink" title="非聚族索引"></a>非聚族索引</h3><p>非聚族索引就好比字典里的偏旁、笔画索引，其 索引组织顺序和数据组织顺序不一致 ，因此非聚族索引可以创建多个。当查找一条数据时，非聚族索引和聚族索引的效率相差不大，但查找一批数据(n)时，非聚族索引需要的io可能是聚族索引的n倍，因为非聚族索引需要一条一条地进行查找。<br><img src="/2016/10/14/oracle-index/index/5.jpg" alt="B-Tree Index" title="B-Tree Index"> </p>
<p>原文地址：<a href="http://orange5458.iteye.com/blog/1165319" target="_blank" rel="external">http://orange5458.iteye.com/blog/1165319</a></p>
]]></content>
      
        <categories>
            
            <category> Oracle </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[windows及linux环境下永久修改pip镜像源的方法]]></title>
      <url>/2016/04/10/pip-source/</url>
      <content type="html"><![CDATA[<h4 id="一、在windows环境下修改pip镜像源的方法-以python3-5为例"><a href="#一、在windows环境下修改pip镜像源的方法-以python3-5为例" class="headerlink" title="一、在windows环境下修改pip镜像源的方法(以python3.5为例)"></a>一、在windows环境下修改pip镜像源的方法(以python3.5为例)</h4><p>(1):在windows文件管理器中,输入 %APPDATA%<br><img src="/2016/04/10/pip-source/1.jpg" alt="B-Tree Index" title="B-Tree Index"> </p>
<p>(2):会定位到一个新的目录下，在该目录下新建pip文件夹，然后到pip文件夹里面去新建个pip.ini文件<br><img src="/2016/04/10/pip-source/2.jpg" alt="B-Tree Index" title="B-Tree Index"> </p>
<p>(3):在新建的pip.ini文件中输入以下内容，搞定 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">global</span>]</div><div class="line">timeout = <span class="number">6000</span></div><div class="line">index-url = http://pypi.douban.com/simple</div><div class="line">trusted-host = pypi.douban.com</div></pre></td></tr></table></figure>
<h4 id="二、在linux系统中更新pip源的方式-以centos-python2-7为例"><a href="#二、在linux系统中更新pip源的方式-以centos-python2-7为例" class="headerlink" title="二、在linux系统中更新pip源的方式(以centos,python2.7为例)"></a>二、在linux系统中更新pip源的方式(以centos,python2.7为例)</h4><p>在linux环境下的修改方式和在windows环境下修改方式基本相同，这里简单总结一下:</p>
<p>(1):在用户的根目录下面创建名为.pip文件夹</p>
<p>(2):在创建好的.pip文件夹中创建名为pip.conf的文件</p>
<p>(3):在pip.conf文件中输入以下内容，ok!!!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">global</span>]</div><div class="line">timeout = <span class="number">6000</span></div><div class="line">index-url = http://pypi.douban.com/simple</div><div class="line">trusted-host = pypi.douban.com</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
